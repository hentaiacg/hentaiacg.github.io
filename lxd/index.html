<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>LXD General Command | Rishinyan</title><meta name="author" content="Rishinyan,shinyanri@gmail.com"><meta name="copyright" content="Rishinyan"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="LXD 介绍 lxd是lxc容器管理的一种。LXC(Linux Containers)是一种轻量级的虚拟化技术，它允许在 Linux 系统上创建和管理容器。每个容器都有自己的文件系统、进程空间和网络栈，但共享宿主机的内核。 之前用过docker，podman和kubernetes，但LXD更偏向于虚拟机，简化 LXC 容器的管理，更接近于完整系统隔离的容器环境，docker和podman更像一种应">
<meta property="og:type" content="article">
<meta property="og:title" content="LXD General Command">
<meta property="og:url" content="https://blog.rishinyan.top/lxd/">
<meta property="og:site_name" content="Rishinyan">
<meta property="og:description" content="LXD 介绍 lxd是lxc容器管理的一种。LXC(Linux Containers)是一种轻量级的虚拟化技术，它允许在 Linux 系统上创建和管理容器。每个容器都有自己的文件系统、进程空间和网络栈，但共享宿主机的内核。 之前用过docker，podman和kubernetes，但LXD更偏向于虚拟机，简化 LXC 容器的管理，更接近于完整系统隔离的容器环境，docker和podman更像一种应">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://ff09945.webp.li/MorishimaHaruka_3.png">
<meta property="article:published_time" content="2024-05-05T16:00:00.000Z">
<meta property="article:modified_time" content="2025-03-14T08:45:26.000Z">
<meta property="article:author" content="Rishinyan">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://ff09945.webp.li/MorishimaHaruka_3.png"><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "LXD General Command",
  "url": "https://blog.rishinyan.top/lxd/",
  "image": "https://ff09945.webp.li/MorishimaHaruka_3.png",
  "datePublished": "2024-05-05T16:00:00.000Z",
  "dateModified": "2025-03-14T08:45:26.000Z",
  "author": [
    {
      "@type": "Person",
      "name": "Rishinyan",
      "url": "https://blog.rishinyan.top/"
    }
  ]
}</script><link rel="shortcut icon" href="https://ff09945.webp.li/watch_neko.jpg"><link rel="canonical" href="https://blog.rishinyan.top/lxd/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//static.cloudflareinsights.com"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.css" media="print" onload="this.media='all'"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!false && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          theme === 'dark' ? activateDarkMode() : theme === 'light' ? activateLightMode() : null
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script defer="defer" data-pjax="data-pjax" src="https://static.cloudflareinsights.com/beacon.min.js" data-cf-beacon="{&quot;token&quot;: &quot;50a7ba8f0875473cb18b83fd39f34467&quot;}"></script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":200,"highlightFullpage":false,"highlightMacStyle":true},
  copy: {
    success: '复制成功',
    error: '复制失败',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"limitCount":150,"languages":{"author":"作者: Rishinyan","link":"链接: ","source":"来源: Rishinyan","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},
  lightbox: 'medium_zoom',
  Snackbar: {"chs_to_cht":"已切换为繁体中文","cht_to_chs":"已切换为简体中文","day_to_night":"已切换为深色模式","night_to_day":"已切换为浅色模式","bgLight":"#49b1f5","bgDark":"#1f1f1f","position":"bottom-left"},
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: true,
  islazyloadPlugin: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: true,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'LXD General Command',
  isHighlightShrink: false,
  isToc: true,
  pageType: 'post'
}</script><link rel="stylesheet" href="/css/wave.css"><link rel="stylesheet" href="/css/mouse.css"><link rel="stylesheet" href="/css/progress_bar.css"><meta name="generator" content="Hexo 7.3.0"><link rel="alternate" href="/atom.xml" title="Rishinyan" type="application/atom+xml">
</head><body><div id="loading-box" onclick="document.getElementById(&quot;loading-box&quot;).classList.add(&quot;loaded&quot;)"><div class="loading-bg"><div class="loading-img"></div><div class="loading-image-dot"></div></div></div><script>const preloader = {
  endLoading: () => {
    document.body.style.overflow = 'auto';
    document.getElementById('loading-box').classList.add("loaded")
  },
  initLoading: () => {
    document.body.style.overflow = '';
    document.getElementById('loading-box').classList.remove("loaded")

  }
}
window.addEventListener('load',()=> { preloader.endLoading() })

if (false) {
  document.addEventListener('pjax:send', () => { preloader.initLoading() })
  document.addEventListener('pjax:complete', () => { preloader.endLoading() })
}</script><script>window.paceOptions = {
  restartOnPushState: false
}

btf.addGlobalFn('pjaxSend', () => {
  Pace.restart()
}, 'pace_restart')

</script><link rel="stylesheet" href="/css/progress_bar.css"/><script src="https://cdn.jsdelivr.net/npm/pace-js/pace.min.js"></script><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img text-center"><img src="https://ff09945.webp.li/watch_neko.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data text-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">7</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">3</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">2</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/Jeff/"><i class="fa-fw fas fa-female"></i><span> Jeff</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fa-list"></i><span> CS</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/BigData/"><i class="fa-fw fas fa-database"></i><span> BigData</span></a></li><li><a class="site-page child" href="/MachineLearning/"><i class="fa-fw fas fa-microchip-ai"></i><span> MachineLearning</span></a></li></ul></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url(https://ff09945.webp.li/MorishimaHaruka_3.png);"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"></a><a class="nav-page-title" href="/"><span class="site-name">LXD General Command</span></a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/Jeff/"><i class="fa-fw fas fa-female"></i><span> Jeff</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fa-list"></i><span> CS</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/BigData/"><i class="fa-fw fas fa-database"></i><span> BigData</span></a></li><li><a class="site-page child" href="/MachineLearning/"><i class="fa-fw fas fa-microchip-ai"></i><span> MachineLearning</span></a></li></ul></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav><div id="post-info"><h1 class="post-title">LXD General Command</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2024-05-05T16:00:00.000Z" title="发表于 2024-05-06 00:00:00">2024-05-06</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2025-03-14T08:45:26.000Z" title="更新于 2025-03-14 16:45:26">2025-03-14</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">浏览量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div><!-- display waves--><section class="main-hero-waves-area waves-area"><svg class="waves-svg" xmlns="http://www.w3.org/2000/svg" xlink="http://www.w3.org/1999/xlink" viewBox="0 24 150 28" preserveAspectRatio="none" shape-rendering="auto"><defs><path id="gentle-wave" d="M -160 44 c 30 0 58 -18 88 -18 s 58 18 88 18 s 58 -18 88 -18 s 58 18 88 18 v 44 h -352 Z"></path></defs><g class="parallax"><use href="#gentle-wave" x="48" y="0"></use><use href="#gentle-wave" x="48" y="3"></use><use href="#gentle-wave" x="48" y="5"></use><use href="#gentle-wave" x="48" y="7"></use></g></svg></section></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><div id="post-outdate-notice" data="{&quot;limitDay&quot;:365,&quot;messagePrev&quot;:&quot;It has been&quot;,&quot;messageNext&quot;:&quot;days since the last update, the content of the article may be outdated.&quot;,&quot;postUpdate&quot;:&quot;2025-03-14 16:45:26&quot;}" hidden></div><h1>LXD</h1>
<h2 id="介绍">介绍</h2>
<p>lxd是lxc容器管理的一种。LXC(Linux Containers)是一种轻量级的虚拟化技术，它允许在 Linux 系统上创建和管理容器。每个容器都有自己的文件系统、进程空间和网络栈，但共享宿主机的内核。</p>
<p>之前用过docker，podman和kubernetes，但LXD更偏向于虚拟机，简化 LXC 容器的管理，更接近于完整系统隔离的容器环境，docker和podman更像一种应用发布，重点在于快速、轻量级的应用程序部署，kubernetes和docker compose则是容器编排工具。</p>
<p>关于docker和podman的区别，命令大体一样，只需将docker和podman互换。而docker因为只有root用户才能运行docker daemon，可能有安全风险，podman是无根用户模式，直接运行在用户空间，普通用户也能使用。podman与kubernetes的基本单元相同，都是pod，而docker是以容器为基本单元</p>
<h2 id="环境">环境</h2>
<p>Ubuntu 22.04</p>
<p>snappy</p>
<h2 id="安装">安装</h2>
<p>ubuntu</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">安装snapp,zfs和bridge</span></span><br><span class="line">apt-get install snapd zfsutils-linux bridge-utils -y</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">安装lxd</span></span><br><span class="line">snap install lxd</span><br></pre></td></tr></table></figure>
<p>centos7</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">yum install epel-release yum-plugin-copr -y</span><br><span class="line">yum copr enable ngompa/snapcore-el7 -y</span><br><span class="line">yum -y install snapd</span><br><span class="line">systemctl enable --now snapd.socket</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">安装zfs</span></span><br><span class="line">yum install http://download.zfsonlinux.org/epel/zfs-release.el7_4.noarch.rpm -y</span><br><span class="line">yum-config-manager --disable zfs</span><br><span class="line">yum-config-manager --enable zfs-kmod</span><br><span class="line">yum install zfs -y</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">安装lxd</span></span><br><span class="line">systemctl start snapd</span><br><span class="line">snap install lxd</span><br></pre></td></tr></table></figure>
<h2 id="基本操作">基本操作</h2>
<p>创建容器</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">创建并启动容器</span></span><br><span class="line">lxc launch &lt;image_name&gt;:&lt;version&gt;</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">指定一个容器名</span></span><br><span class="line">lxc launch ubuntu:14.04 c1</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">获取全部的 Ubuntu 镜像列表</span></span><br><span class="line">lxc image list ubuntu:</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">全部的非官方镜像</span></span><br><span class="line">lxc image list images:</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">获取某镜像的全部版本</span></span><br><span class="line">lxc image list &lt;image_name&gt;:</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">某个给定的原程仓库的全部别名</span></span><br><span class="line">lxc image alias list &lt;image_name&gt;:</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">创建但不启动一个容器</span></span><br><span class="line">lxc init &lt;image_name&gt;:</span><br></pre></td></tr></table></figure>
<p>容器信息</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">列出所有的容器</span></span><br><span class="line">lxc list 或 lxc ls</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">有大量的选项供你选择来改变被显示出来的列。在一个拥有大量容器的系统上，默认显示的列可能会有点慢（因为必须获取容器中的网络信息），你可以这样做来避免这种情况</span></span><br><span class="line">lxc ls --fast</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">基于名字或者属性来过滤</span></span><br><span class="line">lxc ls security.privileged=true  # 特权容器（禁用了用户命名空间）</span><br><span class="line">lxc ls --fast alpine  # 名字中带有“alpine”的容器,支持复杂的正则表达式</span><br></pre></td></tr></table></figure>
<p>容器的基本信息</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lxc info &lt;container&gt;</span><br></pre></td></tr></table></figure>
<p>启动</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lxc start &lt;container&gt;</span><br></pre></td></tr></table></figure>
<p>停止</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">lxc stop &lt;container&gt;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">强制停止,没有对发出的 SIGPWR 信号产生回应</span></span><br><span class="line">lxc stop &lt;container&gt; --force</span><br></pre></td></tr></table></figure>
<p>重启</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">lxc restart &lt;container&gt;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">强制重启,没有对发出的 SIGINT 信号产生回应</span></span><br><span class="line">lxc restart &lt;container&gt; --force</span><br></pre></td></tr></table></figure>
<p>暂停</p>
<p>容器任务将会被发送相同的 SIGSTOP 信号，这也意味着它们将仍然是可见的，并且仍然会占用内存，但是它们不会从调度程序中得到任何的 CPU 时间片</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lxc pause &lt;container&gt;</span><br></pre></td></tr></table></figure>
<p>删除</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">lxc delete &lt;container&gt;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">如果容器还处于运行状态时你将必须使用“-force”</span></span><br><span class="line">lxc delete &lt;container&gt; --force</span><br></pre></td></tr></table></figure>
<h2 id="容器的配置">容器的配置</h2>
<h3 id="设备">设备</h3>
<ul>
<li>磁盘 既可以是一块物理磁盘，也可以只是一个被挂挂载到容器上的分区，还可以是一个来自主机的绑定挂载路径。</li>
<li>网络接口卡 一块网卡。它可以是一块桥接的虚拟网卡，或者是一块点对点设备，还可以是一块以太局域网设备或者一块已经被连接到容器的真实物理接口。</li>
<li>unix 块设备 一个 UNIX 块设备，比如 /dev/sda</li>
<li>unix 字符设备 一个 UNIX 字符设备，比如 /dev/kvm</li>
<li>none 这种特殊类型被用来隐藏那种可以通过配置文件被继承的设备。</li>
</ul>
<h3 id="配置-profile-文件">配置 profile 文件</h3>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">所有可用的配置文件列表</span></span><br><span class="line">lxc profile ls</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看给定配置文件的内容</span></span><br><span class="line">lxc profile show &lt;profile&gt;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">编辑</span></span><br><span class="line">lxc profile edit &lt;profile&gt;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">改变应用到给定容器的配置文件列表</span></span><br><span class="line">lxc profile apply &lt;container&gt; &lt;profile1&gt;,&lt;profile2&gt;,&lt;profile3&gt;,...</span><br></pre></td></tr></table></figure>
<h3 id="本地配置">本地配置</h3>
<p>有些配置是某个容器特定的，你并不想将它放到配置文件中,修改容器配置</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">lxc config edit &lt;container&gt;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">修改单独的配置</span></span><br><span class="line">lxc config set &lt;container&gt; &lt;key&gt; &lt;value&gt;</span><br></pre></td></tr></table></figure>
<p>添加设备</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lxc config device add my-container kvm unix-char path=/dev/kvm  # 将会为名为“my-container”的容器设置一个 /dev/kvm 项</span><br></pre></td></tr></table></figure>
<h3 id="读取配置">读取配置</h3>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># 读取容器的本地配置</span><br><span class="line">lxc config show &lt;container&gt;</span><br><span class="line"></span><br><span class="line"># 得到已经被展开了的配置（包含了所有的配置值）</span><br><span class="line">lxc config show --expanded &lt;container&gt;</span><br></pre></td></tr></table></figure>
<p>配置值和设备项的设置都会对容器实时发生影响。这意味着在不重启正在运行的容器的情况下，你可以添加和移除某些设备或者修改安全配置文件。</p>
<h2 id="执行环境">执行环境</h2>
<p>与 LXD 在容器内执行命令的方式相比，有一点是不同的，那就是 shell 并不是在容器中运行。这也意味着容器不知道使用的是什么样的 shell，以及设置了什么样的环境变量和你的家目录在哪里。</p>
<p>通过 LXD 来执行命令总是使用最小的路径环境变量设置，并且 HOME 环境变量必定为 /root，以容器的超级用户身份来执行（即 uid 为 0，gid 为 0）。</p>
<p>其他的环境变量可以通过命令行来设置，或者在“environment.”配置中设置成永久环境变量。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">进入shell</span></span><br><span class="line">lxc exec &lt;container&gt; bash</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">复杂的命令要求使用分隔符来合理分隔参数</span></span><br><span class="line">lxc exec &lt;container&gt; -- ls -lh /</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">设置或者重写变量，你可以使用“-<span class="built_in">env</span>”参数</span></span><br><span class="line">lxc exec &lt;container&gt; --env mykey=myvalue env | grep mykey</span><br></pre></td></tr></table></figure>
<h2 id="文件管理">文件管理</h2>
<p>从容器中获得一个文件</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">lxc file pull &lt;container&gt;/&lt;path&gt; &lt;dest&gt;</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">读取到标准输出</span></span><br><span class="line">lxc file pull &lt;container&gt;/&lt;path&gt; -</span><br></pre></td></tr></table></figure>
<p>向容器发送一个文件</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lxc file push &lt;source&gt; &lt;container&gt;/&lt;path&gt;</span><br></pre></td></tr></table></figure>
<p>直接编辑一个文件</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lxc file edit &lt;container&gt;/&lt;path&gt;</span><br></pre></td></tr></table></figure>
<h2 id="快照管理">快照管理</h2>
<p>LXD 允许你对容器执行快照功能并恢复它。快照包括了容器在某一时刻的完整状态（如果<code>-stateful</code>被使用的话将会包括运行状态），这也意味着所有的容器配置，容器设备和容器文件系统也会被保存。</p>
<p>创建快照</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">lxc snapshot &lt;container&gt; # 命令执行完成之后将会生成名为snapX（X 为一个自动增长的数）的记录。</span><br><span class="line">lxc snapshot &lt;container&gt; &lt;snapshot name&gt; # 命名快照</span><br></pre></td></tr></table></figure>
<p>列出所有的快照</p>
<p>一个容器的所有快照的数量可以使用<code>lxc list</code>来得到</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lxc info &lt;container&gt;</span><br></pre></td></tr></table></figure>
<p>恢复快照</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lxc restore &lt;container&gt; &lt;snapshot name&gt;</span><br></pre></td></tr></table></figure>
<p>快照重命名</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lxc move &lt;container&gt;/&lt;snapshot name&gt; &lt;container&gt;/&lt;new snapshot name&gt;</span><br></pre></td></tr></table></figure>
<p>从快照中创建一个新的容器</p>
<p>新的容器除了一些可变的信息将会被重置之外（例如 MAC 地址）其余所有信息都将和快照完全相同</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lxc copy &lt;source container&gt;/&lt;snapshot name&gt; &lt;destination container&gt;</span><br></pre></td></tr></table></figure>
<p>删除快照</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lxc delete &lt;container&gt;/&lt;snapshot name&gt;</span><br></pre></td></tr></table></figure>
<h2 id="克隆并重命名">克隆并重命名</h2>
<p>复制容器</p>
<p>目标容器在所有方面将会完全和源容器等同。除了新的容器没有任何源容器的快照以及一些可变值将会被重置之外（例如 MAC 地址）</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lxc copy &lt;source container&gt; &lt;destination container&gt;</span><br></pre></td></tr></table></figure>
<p>移动快照</p>
<p>“move”命令将会被用作给容器重命名。</p>
<p>唯一的要求就是当容器应该被停止，容器内的任何事情都会被保存成它本来的样子，包括可变化的信息（类似 MAC 地址等）。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lxc move &lt;old name&gt; &lt;new name&gt;</span><br></pre></td></tr></table></figure>
<h2 id="可用资源限制">可用资源限制</h2>
<p>资源限制可以在容器运行时动态更改。某些可能无法启用，例如，如果设置的内存值小于当前内存用量，但 LXD 将会试着设置并且报告失败。</p>
<p>所有的限制也可以通过配置文件继承，在这种情况下每个受影响的容器将受到该限制的约束。也就是说，如果在默认配置文件中设置 <code>limits.memory=256MB</code>，则使用默认配置文件（通常是全都使用）的每个容器的内存限制为 256MB。</p>
<p>不支持资源限制池，将其中的限制由一组容器共享</p>
<p>除了网络限制是通过较旧但是良好的“tc”实现的，上述大多数限制是通过 Linux 内核的 cgroup API 来实现的。</p>
<p>LXD 在启动时会检测你在内核中启用了哪些 cgroup，并且将只应用你的内核支持的限制。如果你缺少一些 cgroup，守护进程会输出警告，接着你的 init 系统将会记录这些。</p>
<p>在 Ubuntu 16.04 上，默认情况下除了内存交换审计外将会启用所有限制，内存交换审计需要你通过<code>swapaccount = 1</code>这个内核引导参数来启用。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">容器范围的限制</span></span><br><span class="line">lxc config set CONTAINER KEY VALUE</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">对于配置文件设置</span></span><br><span class="line">lxc profile set PROFILE KEY VALUE</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">指定特定设备</span></span><br><span class="line">lxc config device set CONTAINER DEVICE KEY VALUE</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">对于配置文件设置</span></span><br><span class="line">lxc profile device set PROFILE DEVICE KEY VALUE</span><br></pre></td></tr></table></figure>
<p><a target="_blank" rel="noopener" href="https://github.com/lxc/incus/blob/main/internal/server/metadata/configuration.json">有效配置键、设备类型和设备键的完整列表</a></p>
<h3 id="磁盘">磁盘</h3>
<p>Linux 没有基于路径的配额，而大多数文件系统只有基于用户和组的配额</p>
<p>使用 ZFS 或 btrfs 存储后端，这意味着现在 LXD 只能支持磁盘限制</p>
<p>可能为 LVM 实现此功能，但这取决于与它一起使用的文件系统，并且如果结合实时更新那会变得棘手起来，因为并不是所有的文件系统都允许在线增长，而几乎没有一个允许在线收缩</p>
<p>不像 CPU 和内存，磁盘和 I/O 限制是直接作用在实际的设备上的，因此你需要编辑原始设备或者屏蔽某个具体的设备。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">设置磁盘限制（需要 btrfs 或者 ZFS）</span></span><br><span class="line">lxc config device set my-container root size 20GB</span><br></pre></td></tr></table></figure>
<h3 id="CPU">CPU</h3>
<ul>
<li>
<p>X 个 CPU 核心<br>
在这种模式下，你让 LXD 为你选择一组核心，然后为更多的容器和 CPU 的上线/下线提供负载均衡。<br>
容器只看到这个数量的 CPU 核心。</p>
</li>
<li>
<p>一组特定的 CPU 核心（例如，核心1、3 和 5）<br>
类似于第一种模式，但是不会做负载均衡，你会被限制在那些核心上，无论它们有多忙。</p>
</li>
<li>
<p>拥有的 20％ 处理能力<br>
在这种模式下，你可以看到所有的 CPU，但调度程序将限制你使用 20％ 的 CPU 时间，但这只有在负载状态才会这样！所以如果系统不忙，你的容器可以跑得很欢。而当其他的容器也开始使用 CPU 时，它会被限制用量。</p>
</li>
<li>
<p>每测量 200ms，给我 50ms（并且不超过）<br>
此模式与上一个模式类似，你可以看到所有的 CPU，但这一次，无论系统可能是多么空闲，你只能使用你设置的极限时间下的尽可能多的 CPU 时间。在没有过量使用的系统上，这可使你可以非常整齐地分割 CPU，并确保这些容器的持续性能。</p>
</li>
</ul>
<p>还可以将前两个中的一个与最后两个之一相结合，即请求一组 CPU，然后进一步限制这些 CPU 的 CPU 时间</p>
<p>除此之外，我们还有一个通用的优先级调节方式，可以告诉调度器当你处于负载状态时，两个争夺资源的容器谁会取得胜利。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">限制使用任意两个 CPU 核心</span></span><br><span class="line">lxc config set my-container limits.cpu 2</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">指定特定的 CPU 核心，比如说第二和第四个</span></span><br><span class="line">lxc config set my-container limits.cpu 1,3</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">设置范围</span></span><br><span class="line">lxc config set my-container limits.cpu 0-3,7-11</span><br></pre></td></tr></table></figure>
<p>注意，为了避免完全混淆用户空间，lxcfs 会重排 <code>/proc/cpuinfo</code> 中的条目，以便没有错误</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">限制容器使用 10% 的 CPU 时间</span></span><br><span class="line">lxc config set my-container limits.cpu.allowance 10%</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">固定的 CPU 时间切片</span></span><br><span class="line">lxc config set my-container limits.cpu.allowance 25ms/200ms</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">容器的 CPU 优先级调到最低</span></span><br><span class="line">lxc config set my-container limits.cpu.priority 0</span><br></pre></td></tr></table></figure>
<h3 id="内存">内存</h3>
<p>支持这种限制以及基于百分比的请求</p>
<p>可以选择在每个容器上打开或者关闭 swap，如果打开，还可以设置优先级，以便你可以选择哪些容器先将内存交换到磁盘</p>
<p>内存限制默认是“hard”。 也就是说，当内存耗尽时，内核将会开始杀掉你的那些进程。</p>
<p>或者，你可以将强制策略设置为“soft”，在这种情况下，只要没有别的进程的情况下，你将被允许使用尽可能多的内存。一旦别的进程想要这块内存，你将无法分配任何内存，直到你低于你的限制或者主机内存再次有空余。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">内存限制 支持的后缀是 KB、MB、GB、TB、PB、EB</span></span><br><span class="line">lxc config set my-container limits.memory 256MB</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">关闭容器的内存交换（默认启用）</span></span><br><span class="line">lxc config set my-container limits.memory.swap false</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">告诉内核首先交换指定容器的内存</span></span><br><span class="line">lxc config set my-container limits.memory.swap.priority 0</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">不想要强制的内存限制</span></span><br><span class="line">lxc config set my-container limits.memory.enforce soft</span><br></pre></td></tr></table></figure>
<h3 id="网络-I-O">网络 I/O</h3>
<p>支持两种限制。</p>
<p>第一个是对网络接口的速率限制。你可以设置入口和出口的限制，或者只是设置“最大”限制然后应用到出口和入口。这个只支持“桥接”和“p2p”类型接口。</p>
<p>第二种是全局网络 I/O 优先级，仅当你的网络接口趋于饱和的时候再使用。</p>
<p>只要机制可用，网络 I/O 基本等同于块 I/O。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">将一个千兆网的连接速度限制到仅仅 100Mbit/s</span></span><br><span class="line">lxc profile device set default eth0 limits.ingress 100Mbit</span><br><span class="line">lxc profile device set default eth0 limits.egress 100Mbit</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">设置一个总体的网络优先级</span></span><br><span class="line">lxc config set my-container limits.network.priority 5</span><br></pre></td></tr></table></figure>
<h3 id="块-I-O">块 I/O</h3>
<p>可以直接设置磁盘的读写 IO 的频率和速率，并且有一个全局的块 I/O 优先级，它会通知 I/O 调度程序更倾向哪个</p>
<p>实现这些功能的底层使用的是完整的块设备。这意味着不能为每个路径设置每个分区的 I/O 限制。</p>
<p>当使用可以支持多个块设备映射到指定的路径（带或者不带 RAID）的 ZFS 或 btrfs 时，并不知道这个路径是哪个块设备提供的</p>
<p>完全有可能，实际上确实有可能，容器使用的多个磁盘挂载点（绑定挂载或直接挂载）可能来自于同一个物理磁盘</p>
<p>为了使限制生效，LXD 具有猜测给定路径所对应块设备的逻辑，这其中包括询问 ZFS 和 btrfs 工具，甚至可以在发现一个文件系统中循环挂载的文件时递归地找出它们</p>
<p>这个逻辑虽然不完美，但通常会找到一组应该应用限制的块设备。LXD 接着记录并移动到下一个路径。当遍历完所有的路径，然后到了非常奇怪的部分。它会平均你为相应块设备设置的限制，然后应用这些。</p>
<p>这意味着你将在容器中“平均”地获得正确的速度，但这也意味着你不能对来自同一个物理磁盘的“/fast”和一个“/slow”目录应用不同的速度限制。 LXD 允许你设置它，但最后，它会给你这两个值的平均值。</p>
<p>不像 CPU 和内存，磁盘和 I/O 限制是直接作用在实际的设备上的，因此你需要编辑原始设备或者屏蔽某个具体的设备。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">限制速度</span></span><br><span class="line">lxc config device set my-container root limits.read 30MB</span><br><span class="line">lxc config device set my-container root.limits.write 10MB</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">限制 IO 频率</span></span><br><span class="line">lxc config device set my-container root limits.read 20Iops</span><br><span class="line">lxc config device set my-container root limits.write 10Iops</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">在一个过量使用的繁忙系统上, 将那个容器的 I/O 优先级调到最高</span></span><br><span class="line">lxc config set my-container limits.disk.priority 10</span><br></pre></td></tr></table></figure>
<h3 id="获取当前资源使用率">获取当前资源使用率</h3>
<p><a target="_blank" rel="noopener" href="https://github.com/lxc/lxd/blob/master/doc/rest-api.md">LXD API</a> 可以导出目前容器资源使用情况的一点信息，你可以得到：</p>
<ul>
<li>内存：当前、峰值、目前内存交换和峰值内存交换</li>
<li>磁盘：当前磁盘使用率</li>
<li>网络：每个接口传输的字节和包数。</li>
</ul>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lxc info</span><br></pre></td></tr></table></figure>
<h2 id="镜像">镜像</h2>
<p>LXC 1.0 “下载”模板，它允许用户下载预先打包的容器镜像，用模板脚本在中央服务器上生成，接着高度压缩、签名并通过 https 分发。很多用户从旧版的容器生成方式切换到了使用这种新的、更快更可靠的创建容器的方式。</p>
<p>所有容器都是从镜像创建的，在 LXD 中具有高级镜像缓存和预加载支持，以使镜像存储保持最新。</p>
<p>所有的容器都是由镜像创建的。镜像可以来自一台远程服务器并使用它的完整 hash、短 hash 或者别名拉取下来，但是最终每个 LXD 容器都是创建自一个本地镜像</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">lxc launch ubuntu:14.04 c1</span><br><span class="line">lxc launch ubuntu:75182b1241be475a64e68a518ce853e800e9b50397d2f152816c24f038c94d6e c2</span><br><span class="line">lxc launch ubuntu:75182b1241be c3</span><br></pre></td></tr></table></figure>
<p>所有这些引用相同的远程镜像，在第一次运行这些命令其中之一时，远程镜像将作为缓存镜像导入本地 LXD 镜像存储，接着从其创建容器。</p>
<p>下一次运行其中一个命令时，LXD 将只检查镜像是否仍然是最新的（当不是由指纹引用时），如果是，它将创建容器而不下载任何东西。</p>
<p>现在镜像被缓存在本地镜像存储中，你也可以从那里启动它，甚至不检查它是否是最新的：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lxc launch 75182b1241be c4</span><br></pre></td></tr></table></figure>
<h3 id="手动导入镜像">手动导入镜像</h3>
<p>如果你想复制远程的某个镜像到你本地镜像存储，但不立即从它创建一个容器，你可以使用<code>lxc image copy</code>命令。它可以让你调整一些镜像标志</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lxc image copy ubuntu:14.04 local:</span><br></pre></td></tr></table></figure>
<p>通过比记住其指纹更容易的方式来记住你引用的镜像副本，则可以在复制时添加别名</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">lxc image copy ubuntu:12.04 local: --alias old-ubuntu</span><br><span class="line">lxc launch old-ubuntu c6</span><br></pre></td></tr></table></figure>
<p>使用源服务器上设置的别名，你可以要求 LXD 复制下来</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">lxc image copy ubuntu:15.10 local: --copy-aliases</span><br><span class="line">lxc launch 15.10 c7</span><br></pre></td></tr></table></figure>
<p>上面的副本都是一次性拷贝，也就是复制远程镜像的当前版本到本地镜像存储中。如果你想要 LXD 保持镜像最新，就像它在缓存中存储的那样，你需要使用 <code>–auto-update</code> 标志：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lxc image copy images:gentoo/current/amd64 local: --alias gentoo --auto-update</span><br></pre></td></tr></table></figure>
<h3 id="导入-tarball">导入 tarball</h3>
<p>提供了一个单独的 tarball</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lxc image import &lt;tarball&gt;</span><br></pre></td></tr></table></figure>
<p>导入时设置一个别名</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lxc image import &lt;tarball&gt; --alias random-image</span><br></pre></td></tr></table></figure>
<p>给了两个 tarball，要识别哪个是含有 LXD 元数据的。通常可以通过 tarball 的名称来识别，如果不行就选择最小的那个，元数据 tarball 包是很小的。 然后将它们一起导入</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lxc image import &lt;metadata tarball&gt; &lt;rootfs tarball&gt;</span><br></pre></td></tr></table></figure>
<h3 id="从-URL-中导入">从 URL 中导入</h3>
<p>如果你的一台 https Web 服务器的某个路径中有 <code>LXD-Image-URL</code> 和 <code>LXD-Image-Hash</code> 的标头设置，那么 LXD 就会把这个镜像拉到镜像存储中。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lxc image import https://dl.stgraber.org/lxd --alias busybox-amd64</span><br></pre></td></tr></table></figure>
<p>当拉取镜像时，LXD 还会设置一些标头，远程服务器可以检查它们以返回适当的镜像。 它们是 <code>LXD-Server-Architectures</code> 和 <code>LXD-Server-Version</code>。</p>
<p>这相当于一个简陋的镜像服务器。 它可以通过任何静态 Web 服务器提供一中用户友好的导入镜像的方式。</p>
<h3 id="管理本地镜像存储">管理本地镜像存储</h3>
<p>列出镜像</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lxc image list</span><br></pre></td></tr></table></figure>
<p>以通过别名或者指纹来过滤</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lxc image list amd64</span><br></pre></td></tr></table></figure>
<p>指定一个镜像属性中的键值对来过滤</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lxc image list os=ubuntu</span><br></pre></td></tr></table></figure>
<p>了解镜像的所有信息</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lxc image info ubuntu</span><br></pre></td></tr></table></figure>
<p>编辑镜像</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lxc image edit &lt;alias or fingerprint&gt;</span><br></pre></td></tr></table></figure>
<p>删除镜像,注意你不必移除缓存对象，它们会在过期后被 LXD 自动移除（默认上，在最后一次使用的 10 天后）。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lxc image delete &lt;alias or fingerprint&gt;</span><br></pre></td></tr></table></figure>
<p>导出镜像 得到目前镜像的 tarball</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lxc image export old-ubuntu .</span><br></pre></td></tr></table></figure>
<h3 id="镜像格式">镜像格式</h3>
<p>LXD 现在支持两种镜像布局，unified 或者 split。这两者都是有效的 LXD 格式，虽然后者在与其他容器或虚拟机一起运行时更容易重用其文件系统。</p>
<p>不支持任何应用程序容器的“标准”镜像格式,有关<a target="_blank" rel="noopener" href="https://github.com/lxc/lxd/blob/master/doc/image-handling.md">镜像格式</a>的最新详细信息，请参阅此文档。</p>
<h4 id="unified-镜像（一个-tarball）">unified 镜像（一个 tarball）</h4>
<p>unified 镜像格式是 LXD 在生成镜像时使用的格式。它们是一个单独的大型 tarball，包含 <code>rootfs</code> 目录下的容器文件系统，在 tarball 根目录下有 <code>metadata.yaml</code> 文件，任何模板都放到 <code>templates</code> 目录。</p>
<p>tarball 可以用任何方式压缩（或者不压缩）。镜像散列是压缩后的 tarball 的 sha256 。</p>
<h4 id="Split-镜像（两个-tarball）">Split 镜像（两个 tarball）</h4>
<p>这种格式最常用于滚动更新镜像并已经有了一个压缩文件系统 tarball 时。</p>
<p>它们由两个不同的 tarball 组成，第一个只包含 LXD 使用的元数据， <code>metadata.yaml</code> 文件在根目录，任何模板都在 <code>templates</code> 目录。</p>
<p>第二个 tarball 只包含直接位于其根目录下的容器文件系统。大多数发行版已经有这样的 tarball，因为它们常用于引导新机器。 此镜像格式允许不经修改就重用。</p>
<p>两个 tarball 都可以压缩（或者不压缩），它们可以使用不同的压缩算法。 镜像散列是元数据的 tarball 和 rootfs 的 tarball 结合的 sha256。</p>
<h4 id="镜像元数据">镜像元数据</h4>
<p>metadata.yaml</p>
<figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line">architecture: <span class="string">&quot;x86_64&quot;</span></span><br><span class="line">creation_date: <span class="number">1573140590</span></span><br><span class="line">properties:</span><br><span class="line">    architecture: <span class="string">&quot;x86_64&quot;</span></span><br><span class="line">    description: <span class="string">&quot;Ubuntu 14.04 LTS server (20191107)&quot;</span></span><br><span class="line">    os: <span class="string">&quot;ubuntu&quot;</span></span><br><span class="line">    release: <span class="string">&quot;trusty&quot;</span></span><br><span class="line">templates:</span><br><span class="line">    /etc/<span class="built_in">hostname</span>:</span><br><span class="line">        when:</span><br><span class="line">            - create</span><br><span class="line">            - <span class="keyword">copy</span></span><br><span class="line">        template: <span class="built_in">hostname</span>.tpl</span><br><span class="line">    /var/lib/cloud/seed/nocloud-net/meta-data:</span><br><span class="line">        when:</span><br><span class="line">            - create</span><br><span class="line">            - <span class="keyword">copy</span></span><br><span class="line">        template: cloud-init-meta.tpl</span><br><span class="line">    /var/lib/cloud/seed/nocloud-net/user-data:</span><br><span class="line">        when:</span><br><span class="line">            - create</span><br><span class="line">            - <span class="keyword">copy</span></span><br><span class="line">        template: cloud-init-user.tpl</span><br><span class="line">        properties:</span><br><span class="line">            default: |</span><br><span class="line">                #cloud-config</span><br><span class="line">                &#123;&#125;</span><br><span class="line">    /var/lib/cloud/seed/nocloud-net/vendor-data:</span><br><span class="line">        when:</span><br><span class="line">            - create</span><br><span class="line">            - <span class="keyword">copy</span></span><br><span class="line">        template: cloud-init-vendor.tpl</span><br><span class="line">        properties:</span><br><span class="line">            default: |</span><br><span class="line">                #cloud-config</span><br><span class="line">                &#123;&#125;</span><br><span class="line">    /etc/network/interfaces.d/eth0.cfg:</span><br><span class="line">        when:</span><br><span class="line">            - create</span><br><span class="line">        template: interfaces.tpl</span><br><span class="line">    /etc/init/console.override:</span><br><span class="line">        when:</span><br><span class="line">            - create</span><br><span class="line">        template: upstart-override.tpl</span><br><span class="line">    /etc/init/tty1.override:</span><br><span class="line">        when:</span><br><span class="line">            - create</span><br><span class="line">        template: upstart-override.tpl</span><br><span class="line">    /etc/init/tty2.override:</span><br><span class="line">        when:</span><br><span class="line">            - create</span><br><span class="line">        template: upstart-override.tpl</span><br><span class="line">    /etc/init/tty3.override:</span><br><span class="line">        when:</span><br><span class="line">            - create</span><br><span class="line">        template: upstart-override.tpl</span><br><span class="line">    /etc/init/tty4.override:</span><br><span class="line">        when:</span><br><span class="line">            - create</span><br><span class="line">        template: upstart-override.tpl</span><br></pre></td></tr></table></figure>
<p>两个唯一的必填字段是 <code>creation date</code>（UNIX 纪元时间）和 <code>architecture</code>。 其他都可以保持未设置，镜像就可以正常地导入。</p>
<p>额外的属性主要是帮助用户弄清楚镜像是什么。 例如 <code>description</code> 属性是在 <code>lxc image list</code> 中可见的。 用户可以使用其它属性的键/值对来搜索特定镜像。</p>
<p>相反，这些属性用户可以通过 <code>lxc image edit</code>来编辑，<code>creation date</code> 和 <code>architecture</code> 字段是不可变的。</p>
<p>模板机制允许在容器生命周期中的某一点生成或重新生成容器中的一些文件。</p>
<p>使用 <a target="_blank" rel="noopener" href="https://github.com/flosch/pongo2">pongo2 模板引擎</a>来做这些，将所有我们知道的容器信息都导出到模板。 这样，你可以使用用户定义的容器属性或常规 LXD 属性来自定义镜像，从而更改某些特定文件的内容。</p>
<p>正如你在上面的例子中看到的，我们使用在 Ubuntu 中使用它们来进行 <code>cloud-init</code> 并关闭一些 init 脚本。</p>
<h3 id="将容器变成镜像">将容器变成镜像</h3>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lxc publish my-container --alias my-new-image</span><br></pre></td></tr></table></figure>
<p>容器过去的快照变成镜像</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lxc publish my-container/some-snapshot --alias some-image</span><br></pre></td></tr></table></figure>
<h3 id="手动构建镜像">手动构建镜像</h3>
<p>构建你自己的镜像也很简单。</p>
<ol>
<li>生成容器文件系统。这完全取决于你使用的发行版。对于 Ubuntu 和 Debian，它将用于启动。</li>
<li>配置容器中该发行版正常工作所需的任何东西（如果需要任何东西）。</li>
<li>制作该容器文件系统的 tarball，可选择压缩它。</li>
<li>根据上面描述的内容写一个新的 <code>metadata.yaml</code> 文件。</li>
<li>创建另一个包含 <code>metadata.yaml</code> 文件的 tarball。</li>
<li>用下面的命令导入这两个 tarball 作为 LXD 镜像：<code>lxc image import &lt;metadata tarball&gt; &lt;rootfs tarball&gt; --alias some-name</code></li>
</ol>
<p>在一切都正常工作前你可能需要经历几次这样的工作，调整这里或那里，可能会添加一些模板和属性。</p>
<p>所有 LXD 守护程序都充当镜像服务器。除非另有说明，否则加载到镜像存储中的所有镜像都会被标记为私有，因此只有受信任的客户端可以检索这些镜像，但是如果要创建公共镜像服务器，你需要做的是将一些镜像标记为公开，并确保你的 LXD 守护进程监听网络。</p>
<h4 id="只运行-LXD-公共服务器">只运行 LXD 公共服务器</h4>
<p>最简单的共享镜像的方式是运行一个公共的 LXD 守护进程。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lxc config set core.https_address &quot;[::]:8443&quot;</span><br></pre></td></tr></table></figure>
<p>远程用户就可以添加你的服务器作为公共服务器：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lxc remote add &lt;some name&gt; &lt;IP or DNS&gt; --public</span><br></pre></td></tr></table></figure>
<p>他们就可以像使用任何默认的镜像服务器一样使用它们。 由于远程服务器添加了 <code>-public</code> 选项，因此不需要身份验证，并且客户端仅限于使用已标记为 <code>public</code> 的镜像。</p>
<p>要将镜像设置成公共的，只需使用 <code>lxc image edit</code> 编辑它们，并将 <code>public</code> 标志设置为 <code>true</code>。</p>
<h2 id="远程主机及容器迁移">远程主机及容器迁移</h2>
<p>XD 2.0 支持两种协议:</p>
<ul>
<li>LXD 1.0 API：这是在客户端和 LXD 守护进程之间使用的 REST API，以及在 LXD 守护进程间复制/移动镜像和容器时使用的 REST API。</li>
<li>Simplestreams：Simplestreams 协议是 LXD 客户端和守护进程使用的只读、仅针对镜像的协议，用于客户端和 LXD 守护进程获取镜像信息以及从一些公共镜像服务器（如 Ubuntu 镜像）导入镜像。</li>
</ul>
<p>以下所有内容都将使用这两个协议中的第一个。</p>
<p>LXD API 的验证是通过客户端证书在 TLS 1.2 上使用最近的密钥验证的。 当两个 LXD 守护进程必须直接交换信息时，源守护程序生成一个临时令牌，并通过客户端传输到目标守护程序。 此令牌仅可用于访问特定流，并且会被立即撤销，因此不能重新使用。</p>
<p>为了避免中间人攻击，客户端工具还将源服务器的证书发送到目标服务器。这意味着对于特定的下载操作，目标服务器会被提供源服务器的 URL、所需资源的一次性访问令牌以及服务器应该使用的证书。 这可以防止中间人攻击，并且只允许临时访问所传输的对象。</p>
<p>LXD 2.0 使用这样一种模型，某个操作的目标（接收端）直接连接到源以获取数据。</p>
<p>这意味着你必须确保目标服务器可以直接连接到源、可以更新任何所需的防火墙。</p>
<p>有个<a target="_blank" rel="noopener" href="https://github.com/lxc/lxd/issues/553">允许反向连接的计划</a>，允许通过客户端代理本身以应对那些严格的防火墙阻止两台主机之间通信的罕见情况。</p>
<h3 id="与远程主机交互">与远程主机交互</h3>
<p>默认情况下，唯一真正的 LXD 远程配置是 <code>local:</code>，这也是默认的远程（所以你不必输入它的名称）。这个本地（<code>local:</code>）远程使用 LXD REST API 通过 unix 套接字与本地守护进程通信。</p>
<p>假设你已经有两台装有 LXD 的机器：你的本机以及远程那台我们称为“foo”的主机。</p>
<p>首先你需要确保“foo”正在监听网络，并设置了一个密码，以便得到一个远程 shell，运行：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">lxc config set core.https_address [::]:8443</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">lxd 6.1后已经舍弃, https://discourse.ubuntu.com/t/lxd-6-1-has-been-released/46259</span></span><br><span class="line">lxc config set core.trust_password something-secure</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">使用token</span></span><br><span class="line">lxc config trust add</span><br></pre></td></tr></table></figure>
<p>在你本地 LXD 上，你需要使它对网络可见，这样我们可以从它传输容器和镜像：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lxc config set core.https_address [::]:8443</span><br></pre></td></tr></table></figure>
<p>现在已经在两端完成了守护进程的配置，你可以添加“foo”到你的本地客户端,（将 1.2.3.4 替换成你的 IP 或者 FQDN）</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lxc remote add foo 1.2.3.4</span><br></pre></td></tr></table></figure>
<p>远程列表</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lxc remote list</span><br></pre></td></tr></table></figure>
<p>远程创建</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lxc launch ubuntu:14.04 foo:c1</span><br></pre></td></tr></table></figure>
<p>列出远程主机正在运行的容器</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lxc list foo:</span><br></pre></td></tr></table></figure>
<p>需要在远程主机上同时指定镜像和容器。因此如果你在“foo”上有一个“my-image”的镜像，并且希望从它创建一个“c2”的容器，你需要运行：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lxc launch foo:my-image foo:c2</span><br></pre></td></tr></table></figure>
<p>得到一个远程容器的 shell</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lxc exec foo:c1 bash</span><br></pre></td></tr></table></figure>
<p>复制容器</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">lxc copy foo:c1 c2</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">你会有一个新的从远程“c1”复制过来的本地“c2”容器。这需要停止“c1”容器，但是你可以在运行的时候只复制一个快照：</span></span><br><span class="line">lxc snapshot foo:c1 current</span><br><span class="line">lxc copy foo:c1/current c3</span><br></pre></td></tr></table></figure>
<p>移动容器</p>
<p>除非你在做实时迁移，不然你需要在移动前先停止容器</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">lxc stop foo:c1</span><br><span class="line">lxc move foo:c1 local</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">或</span></span><br><span class="line">lxc move foo:c1 c1</span><br></pre></td></tr></table></figure>
<p>远程容器的交互时 LXD 使用的 REST API 并不是通过本地 Unix 套接字，而是通过 HTTPS 传输</p>
<p>当两个守护程序之间交互时会变得有些棘手，如复制和移动的情况。在这种情况下会发生：</p>
<ol>
<li>用户运行<code>lxc move foo：c1 c1</code>。</li>
<li>客户端联系 <code>local:</code> 远程以检查是否现有“c1”容器。</li>
<li>客户端从“foo”获取容器信息。</li>
<li>客户端从源“foo”守护程序请求迁移令牌。</li>
<li>客户端将迁移令牌以及源 URL 和“foo”的证书发送到本地 LXD 守护程序以及容器配置和周围设备。</li>
<li>然后本地 LXD 守护程序使用提供的令牌直接连接到“foo” a) 它连接到第一个控制 websocket    b) 它协商文件系统传输协议（zfs 发送/接收，btrfs 发送/接收或者纯 rsync）    c) 如果在本地可用，它会解压用于创建源容器的镜像。这是为了避免不必要的数据传输。    d) 然后它会将容器及其任何快照作为增量传输。</li>
<li>如果成功，客户端会命令“foo”删除源容器。</li>
</ol>
<h2 id="容器检查点和恢复">容器检查点和恢复</h2>
<p>检查点/恢复意味着正在运行的容器状态可以被序列化到磁盘，要么可以作为同一主机上的有状态快照，要么放到另一主机上相当于实时迁移</p>
<h3 id="要求">要求</h3>
<p>要使用容器实时迁移和有状态快照，你需要以下条件：</p>
<ul>
<li>一个非常新的 Linux 内核，4.4 或更高版本。</li>
<li>CRIU 2.0，可能需要一些 cherry-pick 的提交，具体取决于你确切的内核配置。</li>
<li>直接在主机上运行 LXD。 不能在容器嵌套下使用这些功能。</li>
<li>对于迁移，目标主机必须至少实现源主机的指令集，目标主机内核必须至少提供与源主机相同的系统调用，并且在源主机上挂载的任何内核文件系统也必须可挂载到目标主机上。</li>
</ul>
<p>Ubuntu 16.04 LTS 已经提供了所有需要的依赖，在这种情况下，您只需要安装 CRIU 本身：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">add-apt-repository ppa:criu/ppa</span><br><span class="line">apt install criu -y</span><br><span class="line">snap set lxd criu.enable=true</span><br><span class="line">systemctl reload snap.lxd.daemon</span><br></pre></td></tr></table></figure>
<h3 id="使用-CRIU">使用 CRIU</h3>
<h4 id="有状态快照">有状态快照</h4>
<p>测试24.04无法执行，有嵌套空间的错误，但Ubuntu 16.04可以正常执行</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lxc snapshot c1 second --stateful</span><br></pre></td></tr></table></figure>
<p>意味着所有容器运行时状态都被序列化到磁盘并且作为了快照的一部分。可以像你还原无状态快照那样还原一个有状态快照</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lxc restore c1 second</span><br></pre></td></tr></table></figure>
<h4 id="有状态快照的停止-启动">有状态快照的停止/启动</h4>
<p>由于升级内核或者其他类似的维护而需要重启机器。与其等待重启后启动所有的容器</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lxc stop c1 --stateful</span><br></pre></td></tr></table></figure>
<p>容器状态将会写入到磁盘，会在下次启动时读取。</p>
<p>还原容器</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lxc start c1</span><br></pre></td></tr></table></figure>
<h3 id="实时迁移">实时迁移</h3>
<p>实时迁移基本上与上面的有状态快照的停止/启动相同，除了容器目录和配置被移动到另一台机器上。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">stgraber@dakara:~$ lxc list c1</span><br><span class="line">+------+---------+-----------------------+----------------------------------------------+------------+-----------+</span><br><span class="line">| NAME |  STATE  |          IPV4         |                     IPV6                     |    TYPE    | SNAPSHOTS |</span><br><span class="line">+------+---------+-----------------------+----------------------------------------------+------------+-----------+</span><br><span class="line">| c1   | RUNNING | 10.178.150.197 (eth0) | 2001:470:b368:4242:216:3eff:fe19:27b0 (eth0) | PERSISTENT | 2         |</span><br><span class="line">+------+---------+-----------------------+----------------------------------------------+------------+-----------+</span><br><span class="line">stgraber@dakara:~$ lxc list s-tollana:</span><br><span class="line">+------+-------+------+------+------+-----------+</span><br><span class="line">| NAME | STATE | IPV4 | IPV6 | TYPE | SNAPSHOTS |</span><br><span class="line">+------+-------+------+------+------+-----------+</span><br><span class="line">stgraber@dakara:~$ lxc move c1 s-tollana:</span><br><span class="line">stgraber@dakara:~$ lxc list c1</span><br><span class="line">+------+-------+------+------+------+-----------+</span><br><span class="line">| NAME | STATE | IPV4 | IPV6 | TYPE | SNAPSHOTS |</span><br><span class="line">+------+-------+------+------+------+-----------+</span><br><span class="line">stgraber@dakara:~$ lxc list s-tollana:</span><br><span class="line">+------+---------+-----------------------+----------------------------------------------+------------+-----------+</span><br><span class="line">| NAME |  STATE  |          IPV4         |                     IPV6                     |    TYPE    | SNAPSHOTS |</span><br><span class="line">+------+---------+-----------------------+----------------------------------------------+------------+-----------+</span><br><span class="line">| c1   | RUNNING | 10.178.150.197 (eth0) | 2001:470:b368:4242:216:3eff:fe19:27b0 (eth0) | PERSISTENT | 2         |</span><br><span class="line">+------+---------+-----------------------+----------------------------------------------+------------+-----------+</span><br></pre></td></tr></table></figure>
<h2 id="引用">引用</h2>
<p>1.<a target="_blank" rel="noopener" href="https://blog.csdn.net/a772304419/article/details/131503515">LXC（Linux Containers）介绍、安装、使用及与Docker的区别与联系-CSDN博客</a></p>
<p>2.<a target="_blank" rel="noopener" href="https://cn.linux-console.net/?p=22036">如何使用 Snap 在 CentOS 7 上部署 LXD</a></p>
<p>3.<a target="_blank" rel="noopener" href="https://www.jianshu.com/p/e69b03c89bac">Centos上安装LXD - 简书</a></p>
<p>4.<a target="_blank" rel="noopener" href="https://linux.cn/article-7618-1.html">容器与云|LXD 2.0 系列（一）：LXD 入门</a></p>
<p>5.<a target="_blank" rel="noopener" href="https://blog.csdn.net/allway2/article/details/122293678">在 CentOS 8 上使用 LXC / LXD 运行 Linux 容器_centos8安装lxc-CSDN博客</a></p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="https://blog.rishinyan.top">Rishinyan</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="https://blog.rishinyan.top/lxd/">https://blog.rishinyan.top/lxd/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来源 <a href="https://blog.rishinyan.top" target="_blank">Rishinyan</a>！</span></div></div><div class="tag_share"><div class="post-share"><div class="social-share" data-image="https://ff09945.webp.li/MorishimaHaruka_3.png" data-sites="twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><hr class="custom-hr"/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div id="gitalk-container"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src="https://ff09945.webp.li/watch_neko.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">Rishinyan</div><div class="author-info-description">Rishinyan's Blog</div><div class="site-data"><a href="/archives/"><div class="headline">文章</div><div class="length-num">7</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">3</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">2</div></a></div><div class="card-info-social-icons"><a class="social-icon" href="https://github.com/hentaiacg" target="_blank" title="Github"><i class="fab fa-github" style="color: #24292e;"></i></a><a class="social-icon" href="mailto:shinyanri@gmail.com" target="_blank" title="Email"><i class="fas fa-envelope" style="color: #4a7dbe;"></i></a><a class="social-icon" href="/atom.xml" target="_blank" title=""><i class="fas fa-rss"></i></a><a class="social-icon" href="https://weibo.com/u/3219469802" target="_blank" title="Weibo"><i class="fab fa-weibo" style="color: #d70f0f;"></i></a></div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">1.</span> <span class="toc-text">LXD</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%8B%E7%BB%8D"><span class="toc-number">1.1.</span> <span class="toc-text">介绍</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%8E%AF%E5%A2%83"><span class="toc-number">1.2.</span> <span class="toc-text">环境</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%89%E8%A3%85"><span class="toc-number">1.3.</span> <span class="toc-text">安装</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C"><span class="toc-number">1.4.</span> <span class="toc-text">基本操作</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%B9%E5%99%A8%E7%9A%84%E9%85%8D%E7%BD%AE"><span class="toc-number">1.5.</span> <span class="toc-text">容器的配置</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AE%BE%E5%A4%87"><span class="toc-number">1.5.1.</span> <span class="toc-text">设备</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%85%8D%E7%BD%AE-profile-%E6%96%87%E4%BB%B6"><span class="toc-number">1.5.2.</span> <span class="toc-text">配置 profile 文件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%AC%E5%9C%B0%E9%85%8D%E7%BD%AE"><span class="toc-number">1.5.3.</span> <span class="toc-text">本地配置</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AF%BB%E5%8F%96%E9%85%8D%E7%BD%AE"><span class="toc-number">1.5.4.</span> <span class="toc-text">读取配置</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%89%A7%E8%A1%8C%E7%8E%AF%E5%A2%83"><span class="toc-number">1.6.</span> <span class="toc-text">执行环境</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%96%87%E4%BB%B6%E7%AE%A1%E7%90%86"><span class="toc-number">1.7.</span> <span class="toc-text">文件管理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BF%AB%E7%85%A7%E7%AE%A1%E7%90%86"><span class="toc-number">1.8.</span> <span class="toc-text">快照管理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%8B%E9%9A%86%E5%B9%B6%E9%87%8D%E5%91%BD%E5%90%8D"><span class="toc-number">1.9.</span> <span class="toc-text">克隆并重命名</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%AF%E7%94%A8%E8%B5%84%E6%BA%90%E9%99%90%E5%88%B6"><span class="toc-number">1.10.</span> <span class="toc-text">可用资源限制</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A3%81%E7%9B%98"><span class="toc-number">1.10.1.</span> <span class="toc-text">磁盘</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#CPU"><span class="toc-number">1.10.2.</span> <span class="toc-text">CPU</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%86%85%E5%AD%98"><span class="toc-number">1.10.3.</span> <span class="toc-text">内存</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BD%91%E7%BB%9C-I-O"><span class="toc-number">1.10.4.</span> <span class="toc-text">网络 I&#x2F;O</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9D%97-I-O"><span class="toc-number">1.10.5.</span> <span class="toc-text">块 I&#x2F;O</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%8E%B7%E5%8F%96%E5%BD%93%E5%89%8D%E8%B5%84%E6%BA%90%E4%BD%BF%E7%94%A8%E7%8E%87"><span class="toc-number">1.10.6.</span> <span class="toc-text">获取当前资源使用率</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%95%9C%E5%83%8F"><span class="toc-number">1.11.</span> <span class="toc-text">镜像</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%89%8B%E5%8A%A8%E5%AF%BC%E5%85%A5%E9%95%9C%E5%83%8F"><span class="toc-number">1.11.1.</span> <span class="toc-text">手动导入镜像</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AF%BC%E5%85%A5-tarball"><span class="toc-number">1.11.2.</span> <span class="toc-text">导入 tarball</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%8E-URL-%E4%B8%AD%E5%AF%BC%E5%85%A5"><span class="toc-number">1.11.3.</span> <span class="toc-text">从 URL 中导入</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AE%A1%E7%90%86%E6%9C%AC%E5%9C%B0%E9%95%9C%E5%83%8F%E5%AD%98%E5%82%A8"><span class="toc-number">1.11.4.</span> <span class="toc-text">管理本地镜像存储</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%95%9C%E5%83%8F%E6%A0%BC%E5%BC%8F"><span class="toc-number">1.11.5.</span> <span class="toc-text">镜像格式</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#unified-%E9%95%9C%E5%83%8F%EF%BC%88%E4%B8%80%E4%B8%AA-tarball%EF%BC%89"><span class="toc-number">1.11.5.1.</span> <span class="toc-text">unified 镜像（一个 tarball）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Split-%E9%95%9C%E5%83%8F%EF%BC%88%E4%B8%A4%E4%B8%AA-tarball%EF%BC%89"><span class="toc-number">1.11.5.2.</span> <span class="toc-text">Split 镜像（两个 tarball）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%95%9C%E5%83%8F%E5%85%83%E6%95%B0%E6%8D%AE"><span class="toc-number">1.11.5.3.</span> <span class="toc-text">镜像元数据</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B0%86%E5%AE%B9%E5%99%A8%E5%8F%98%E6%88%90%E9%95%9C%E5%83%8F"><span class="toc-number">1.11.6.</span> <span class="toc-text">将容器变成镜像</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%89%8B%E5%8A%A8%E6%9E%84%E5%BB%BA%E9%95%9C%E5%83%8F"><span class="toc-number">1.11.7.</span> <span class="toc-text">手动构建镜像</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%AA%E8%BF%90%E8%A1%8C-LXD-%E5%85%AC%E5%85%B1%E6%9C%8D%E5%8A%A1%E5%99%A8"><span class="toc-number">1.11.7.1.</span> <span class="toc-text">只运行 LXD 公共服务器</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BF%9C%E7%A8%8B%E4%B8%BB%E6%9C%BA%E5%8F%8A%E5%AE%B9%E5%99%A8%E8%BF%81%E7%A7%BB"><span class="toc-number">1.12.</span> <span class="toc-text">远程主机及容器迁移</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%8E%E8%BF%9C%E7%A8%8B%E4%B8%BB%E6%9C%BA%E4%BA%A4%E4%BA%92"><span class="toc-number">1.12.1.</span> <span class="toc-text">与远程主机交互</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%B9%E5%99%A8%E6%A3%80%E6%9F%A5%E7%82%B9%E5%92%8C%E6%81%A2%E5%A4%8D"><span class="toc-number">1.13.</span> <span class="toc-text">容器检查点和恢复</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A6%81%E6%B1%82"><span class="toc-number">1.13.1.</span> <span class="toc-text">要求</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8-CRIU"><span class="toc-number">1.13.2.</span> <span class="toc-text">使用 CRIU</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9C%89%E7%8A%B6%E6%80%81%E5%BF%AB%E7%85%A7"><span class="toc-number">1.13.2.1.</span> <span class="toc-text">有状态快照</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9C%89%E7%8A%B6%E6%80%81%E5%BF%AB%E7%85%A7%E7%9A%84%E5%81%9C%E6%AD%A2-%E5%90%AF%E5%8A%A8"><span class="toc-number">1.13.2.2.</span> <span class="toc-text">有状态快照的停止&#x2F;启动</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9E%E6%97%B6%E8%BF%81%E7%A7%BB"><span class="toc-number">1.13.3.</span> <span class="toc-text">实时迁移</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BC%95%E7%94%A8"><span class="toc-number">1.14.</span> <span class="toc-text">引用</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/Jeff'sPlaylist/" title="Jeff's Playlist"><img src="https://ff09945.webp.li/MorishimaHaruka_3.png" onerror="this.onerror=null;this.src='https://ff09945.webp.li/MorishimaHaruka_2.png'" alt="Jeff's Playlist"/></a><div class="content"><a class="title" href="/Jeff'sPlaylist/" title="Jeff's Playlist">Jeff's Playlist</a><time datetime="2025-01-11T07:30:00.000Z" title="发表于 2025-01-11 15:30:00">2025-01-11</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/CentosCompliesHadoop/" title="Centos7.9 编译 Hadoop3.4.0"><img src="https://ff09945.webp.li/MorishimaHaruka_3.png" onerror="this.onerror=null;this.src='https://ff09945.webp.li/MorishimaHaruka_2.png'" alt="Centos7.9 编译 Hadoop3.4.0"/></a><div class="content"><a class="title" href="/CentosCompliesHadoop/" title="Centos7.9 编译 Hadoop3.4.0">Centos7.9 编译 Hadoop3.4.0</a><time datetime="2024-07-18T10:33:00.000Z" title="发表于 2024-07-18 18:33:00">2024-07-18</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/JupyterNotebookInstallation/" title="Jupyter Notebook 安装"><img src="https://ff09945.webp.li/MorishimaHaruka_3.png" onerror="this.onerror=null;this.src='https://ff09945.webp.li/MorishimaHaruka_2.png'" alt="Jupyter Notebook 安装"/></a><div class="content"><a class="title" href="/JupyterNotebookInstallation/" title="Jupyter Notebook 安装">Jupyter Notebook 安装</a><time datetime="2024-07-02T16:00:00.000Z" title="发表于 2024-07-03 00:00:00">2024-07-03</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/Kubernetes/" title="Kubernetes 安装"><img src="https://ff09945.webp.li/MorishimaHaruka_3.png" onerror="this.onerror=null;this.src='https://ff09945.webp.li/MorishimaHaruka_2.png'" alt="Kubernetes 安装"/></a><div class="content"><a class="title" href="/Kubernetes/" title="Kubernetes 安装">Kubernetes 安装</a><time datetime="2024-05-31T16:00:00.000Z" title="发表于 2024-06-01 00:00:00">2024-06-01</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/lxd/" title="LXD General Command"><img src="https://ff09945.webp.li/MorishimaHaruka_3.png" onerror="this.onerror=null;this.src='https://ff09945.webp.li/MorishimaHaruka_2.png'" alt="LXD General Command"/></a><div class="content"><a class="title" href="/lxd/" title="LXD General Command">LXD General Command</a><time datetime="2024-05-05T16:00:00.000Z" title="发表于 2024-05-06 00:00:00">2024-05-06</time></div></div></div></div></div></div></main><footer id="footer" style="background: transparent;"><div id="footer-wrap"><!-- display waves--><section class="main-hero-waves-area waves-area"></section><svg class="waves-svg1" xmlns="http://www.w3.org/2000/svg" xlink="http://www.w3.org/1999/xlink" viewBox="0 0 150 40" preserveAspectRatio="none" shape-rendering="auto"><defs><path id="gentle-wave" d="M 0 30 Q 25 15, 50 30 T 100 30 T 150 30 V 50 H 0 Z"></path></defs><g class="parallax"><use href="#gentle-wave" x="48" y="0"></use><use href="#gentle-wave" x="48" y="3"></use><use href="#gentle-wave" x="48" y="5"></use><use href="#gentle-wave" x="48" y="7"></use></g></svg></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="前往评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/medium-zoom/dist/medium-zoom.min.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page/instantpage.min.js" type="module"></script><script src="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.js"></script><div class="js-pjax"><script>(async () => {
  const showKatex = () => {
    document.querySelectorAll('#article-container .katex').forEach(el => el.classList.add('katex-show'))
  }

  if (!window.katex_js_css) {
    window.katex_js_css = true
    await btf.getCSS('https://cdn.jsdelivr.net/npm/katex/dist/katex.min.css')
    if (true) {
      await btf.getScript('https://cdn.jsdelivr.net/npm/katex/dist/contrib/copy-tex.min.js')
    }
  }

  showKatex()
})()</script><script>(() => {
  const isShuoshuo = GLOBAL_CONFIG_SITE.pageType === 'shuoshuo'
  const option = null

  const commentCount = n => {
    const isCommentCount = document.querySelector('#post-meta .gitalk-comment-count')
    if (isCommentCount) {
      isCommentCount.textContent= n
    }
  }

  const initGitalk = (el, path) => {
    if (isShuoshuo) {
      window.shuoshuoComment.destroyGitalk = () => {
        if (el.children.length) {
          el.innerHTML = ''
          el.classList.add('no-comment')
        }
      }
    }

    const gitalk = new Gitalk({
      clientID: 'Ov23liLi5I2iIluEap7Y',
      clientSecret: '51f16c78325c36c02732e0455ab59c8e6537791c',
      repo: 'hentaiacg.github.io',
      owner: 'hentaiacg',
      admin: ['hentaiacg'],
      updateCountCallback: commentCount,
      ...option,
      id: isShuoshuo ? path : (option && option.id) || '65d898a3b0d7d85836930707e616b564'
    })

    gitalk.render('gitalk-container')
  }

  const loadGitalk = async(el, path) => {
    if (typeof Gitalk === 'function') initGitalk(el, path)
    else {
      await btf.getCSS('https://cdn.jsdelivr.net/npm/gitalk/dist/gitalk.min.css')
      await btf.getScript('https://cdn.jsdelivr.net/npm/gitalk/dist/gitalk.min.js')
      initGitalk(el, path)
    }
  }

  if (isShuoshuo) {
    'Gitalk' === 'Gitalk'
      ? window.shuoshuoComment = { loadComment: loadGitalk }
      : window.loadOtherComment = loadGitalk
    return
  }

  if ('Gitalk' === 'Gitalk' || !false) {
    if (false) btf.loadComment(document.getElementById('gitalk-container'), loadGitalk)
    else loadGitalk()
  } else {
    window.loadOtherComment = loadGitalk
  }
})()</script></div><canvas class="fireworks" mobile="false"></canvas><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/fireworks.min.js"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/activate-power-mode.min.js"></script><script>POWERMODE.colorful = true;
POWERMODE.shake = true;
POWERMODE.mobile = false;
document.body.addEventListener('input', POWERMODE);
</script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>